import type { GraphQLClient } from 'graphql-request';
import type { GraphQLClientRequestHeaders } from 'graphql-request/build/cjs/types';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: { input: any; output: any; }
};

export type Card = Node & {
  __typename?: 'Card';
  ancestors?: Maybe<Array<Card>>;
  cardSpecialColor?: Maybe<CardSpecialColor>;
  cardSpecialColorID?: Maybe<Scalars['ID']['output']>;
  cardType: CardType;
  cardTypeID: Scalars['ID']['output'];
  children?: Maybe<Array<Card>>;
  cost?: Maybe<Scalars['String']['output']>;
  deck?: Maybe<Deck>;
  deckID?: Maybe<Scalars['ID']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  hasActionsBoosterIcon: Scalars['Boolean']['output'];
  hasArrow: Scalars['Boolean']['output'];
  hasBonusPointIcon: Scalars['Boolean']['output'];
  hasBreadIcon: Scalars['Boolean']['output'];
  hasBuildingResourceProviderIcon: Scalars['Boolean']['output'];
  hasCropProviderIcon: Scalars['Boolean']['output'];
  hasCutPeatIcon: Scalars['Boolean']['output'];
  hasFarmPlannerIcon: Scalars['Boolean']['output'];
  hasFellTreesIcon: Scalars['Boolean']['output'];
  hasFoodProviderIcon: Scalars['Boolean']['output'];
  hasGoodsProviderIcon: Scalars['Boolean']['output'];
  hasHiringFareIcon: Scalars['Boolean']['output'];
  hasLivestockProviderIcon: Scalars['Boolean']['output'];
  hasNegativeBonusPointIcon: Scalars['Boolean']['output'];
  hasPanIcon: Scalars['Boolean']['output'];
  hasPointsProviderIcon: Scalars['Boolean']['output'];
  hasSlashAndBurnIcon: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  isOfficialJa: Scalars['Boolean']['output'];
  literalID: Scalars['String']['output'];
  minPlayersNumber?: Maybe<Scalars['Int']['output']>;
  nameEn?: Maybe<Scalars['String']['output']>;
  nameJa?: Maybe<Scalars['String']['output']>;
  note?: Maybe<Scalars['String']['output']>;
  playAgricolaCardID?: Maybe<Scalars['String']['output']>;
  prerequisite?: Maybe<Scalars['String']['output']>;
  printedID?: Maybe<Scalars['String']['output']>;
  products?: Maybe<Array<Product>>;
  revision: Revision;
  revisionID: Scalars['ID']['output'];
  specialVictoryPoint?: Maybe<Scalars['String']['output']>;
  victoryPoint?: Maybe<Scalars['Int']['output']>;
};

/** A connection to a list of items. */
export type CardConnection = {
  __typename?: 'CardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CardEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CardEdge = {
  __typename?: 'CardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Card>;
};

export type CardSpecialColor = Node & {
  __typename?: 'CardSpecialColor';
  cards: CardConnection;
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  nameEn?: Maybe<Scalars['String']['output']>;
  nameJa?: Maybe<Scalars['String']['output']>;
};


export type CardSpecialColorCardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CardWhereInput>;
};

/**
 * CardSpecialColorWhereInput is used for filtering CardSpecialColor objects.
 * Input was generated by ent.
 */
export type CardSpecialColorWhereInput = {
  and?: InputMaybe<Array<CardSpecialColorWhereInput>>;
  /** cards edge predicates */
  hasCards?: InputMaybe<Scalars['Boolean']['input']>;
  hasCardsWith?: InputMaybe<Array<CardWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** key field predicates */
  key?: InputMaybe<Scalars['String']['input']>;
  keyContains?: InputMaybe<Scalars['String']['input']>;
  keyContainsFold?: InputMaybe<Scalars['String']['input']>;
  keyEqualFold?: InputMaybe<Scalars['String']['input']>;
  keyGT?: InputMaybe<Scalars['String']['input']>;
  keyGTE?: InputMaybe<Scalars['String']['input']>;
  keyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  keyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  keyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  keyLT?: InputMaybe<Scalars['String']['input']>;
  keyLTE?: InputMaybe<Scalars['String']['input']>;
  keyNEQ?: InputMaybe<Scalars['String']['input']>;
  keyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name_en field predicates */
  nameEn?: InputMaybe<Scalars['String']['input']>;
  nameEnContains?: InputMaybe<Scalars['String']['input']>;
  nameEnContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEnEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameEnGT?: InputMaybe<Scalars['String']['input']>;
  nameEnGTE?: InputMaybe<Scalars['String']['input']>;
  nameEnHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameEnHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameEnIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameEnIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameEnLT?: InputMaybe<Scalars['String']['input']>;
  nameEnLTE?: InputMaybe<Scalars['String']['input']>;
  nameEnNEQ?: InputMaybe<Scalars['String']['input']>;
  nameEnNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameEnNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** name_ja field predicates */
  nameJa?: InputMaybe<Scalars['String']['input']>;
  nameJaContains?: InputMaybe<Scalars['String']['input']>;
  nameJaContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameJaEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameJaGT?: InputMaybe<Scalars['String']['input']>;
  nameJaGTE?: InputMaybe<Scalars['String']['input']>;
  nameJaHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameJaHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameJaIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameJaIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameJaLT?: InputMaybe<Scalars['String']['input']>;
  nameJaLTE?: InputMaybe<Scalars['String']['input']>;
  nameJaNEQ?: InputMaybe<Scalars['String']['input']>;
  nameJaNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameJaNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<CardSpecialColorWhereInput>;
  or?: InputMaybe<Array<CardSpecialColorWhereInput>>;
};

export type CardType = Node & {
  __typename?: 'CardType';
  cards: CardConnection;
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  nameEn?: Maybe<Scalars['String']['output']>;
  nameJa?: Maybe<Scalars['String']['output']>;
};


export type CardTypeCardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CardWhereInput>;
};

/**
 * CardTypeWhereInput is used for filtering CardType objects.
 * Input was generated by ent.
 */
export type CardTypeWhereInput = {
  and?: InputMaybe<Array<CardTypeWhereInput>>;
  /** cards edge predicates */
  hasCards?: InputMaybe<Scalars['Boolean']['input']>;
  hasCardsWith?: InputMaybe<Array<CardWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** key field predicates */
  key?: InputMaybe<Scalars['String']['input']>;
  keyContains?: InputMaybe<Scalars['String']['input']>;
  keyContainsFold?: InputMaybe<Scalars['String']['input']>;
  keyEqualFold?: InputMaybe<Scalars['String']['input']>;
  keyGT?: InputMaybe<Scalars['String']['input']>;
  keyGTE?: InputMaybe<Scalars['String']['input']>;
  keyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  keyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  keyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  keyLT?: InputMaybe<Scalars['String']['input']>;
  keyLTE?: InputMaybe<Scalars['String']['input']>;
  keyNEQ?: InputMaybe<Scalars['String']['input']>;
  keyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name_en field predicates */
  nameEn?: InputMaybe<Scalars['String']['input']>;
  nameEnContains?: InputMaybe<Scalars['String']['input']>;
  nameEnContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEnEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameEnGT?: InputMaybe<Scalars['String']['input']>;
  nameEnGTE?: InputMaybe<Scalars['String']['input']>;
  nameEnHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameEnHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameEnIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameEnIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameEnLT?: InputMaybe<Scalars['String']['input']>;
  nameEnLTE?: InputMaybe<Scalars['String']['input']>;
  nameEnNEQ?: InputMaybe<Scalars['String']['input']>;
  nameEnNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameEnNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** name_ja field predicates */
  nameJa?: InputMaybe<Scalars['String']['input']>;
  nameJaContains?: InputMaybe<Scalars['String']['input']>;
  nameJaContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameJaEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameJaGT?: InputMaybe<Scalars['String']['input']>;
  nameJaGTE?: InputMaybe<Scalars['String']['input']>;
  nameJaHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameJaHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameJaIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameJaIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameJaLT?: InputMaybe<Scalars['String']['input']>;
  nameJaLTE?: InputMaybe<Scalars['String']['input']>;
  nameJaNEQ?: InputMaybe<Scalars['String']['input']>;
  nameJaNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameJaNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<CardTypeWhereInput>;
  or?: InputMaybe<Array<CardTypeWhereInput>>;
};

/**
 * CardWhereInput is used for filtering Card objects.
 * Input was generated by ent.
 */
export type CardWhereInput = {
  and?: InputMaybe<Array<CardWhereInput>>;
  /** card_special_color_id field predicates */
  cardSpecialColorID?: InputMaybe<Scalars['ID']['input']>;
  cardSpecialColorIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  cardSpecialColorIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  cardSpecialColorIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  cardSpecialColorIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  cardSpecialColorIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** card_type_id field predicates */
  cardTypeID?: InputMaybe<Scalars['ID']['input']>;
  cardTypeIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  cardTypeIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  cardTypeIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** cost field predicates */
  cost?: InputMaybe<Scalars['String']['input']>;
  costContains?: InputMaybe<Scalars['String']['input']>;
  costContainsFold?: InputMaybe<Scalars['String']['input']>;
  costEqualFold?: InputMaybe<Scalars['String']['input']>;
  costGT?: InputMaybe<Scalars['String']['input']>;
  costGTE?: InputMaybe<Scalars['String']['input']>;
  costHasPrefix?: InputMaybe<Scalars['String']['input']>;
  costHasSuffix?: InputMaybe<Scalars['String']['input']>;
  costIn?: InputMaybe<Array<Scalars['String']['input']>>;
  costIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  costLT?: InputMaybe<Scalars['String']['input']>;
  costLTE?: InputMaybe<Scalars['String']['input']>;
  costNEQ?: InputMaybe<Scalars['String']['input']>;
  costNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  costNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** deck_id field predicates */
  deckID?: InputMaybe<Scalars['ID']['input']>;
  deckIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  deckIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deckIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  deckIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  deckIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** has_actions_booster_icon field predicates */
  hasActionsBoosterIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasActionsBoosterIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** ancestors edge predicates */
  hasAncestors?: InputMaybe<Scalars['Boolean']['input']>;
  hasAncestorsWith?: InputMaybe<Array<CardWhereInput>>;
  /** has_arrow field predicates */
  hasArrow?: InputMaybe<Scalars['Boolean']['input']>;
  hasArrowNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** has_bonus_point_icon field predicates */
  hasBonusPointIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasBonusPointIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** has_bread_icon field predicates */
  hasBreadIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasBreadIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** has_building_resource_provider_icon field predicates */
  hasBuildingResourceProviderIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasBuildingResourceProviderIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** card_special_color edge predicates */
  hasCardSpecialColor?: InputMaybe<Scalars['Boolean']['input']>;
  hasCardSpecialColorWith?: InputMaybe<Array<CardSpecialColorWhereInput>>;
  /** card_type edge predicates */
  hasCardType?: InputMaybe<Scalars['Boolean']['input']>;
  hasCardTypeWith?: InputMaybe<Array<CardTypeWhereInput>>;
  /** children edge predicates */
  hasChildren?: InputMaybe<Scalars['Boolean']['input']>;
  hasChildrenWith?: InputMaybe<Array<CardWhereInput>>;
  /** has_crop_provider_icon field predicates */
  hasCropProviderIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasCropProviderIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** has_cut_peat_icon field predicates */
  hasCutPeatIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasCutPeatIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** deck edge predicates */
  hasDeck?: InputMaybe<Scalars['Boolean']['input']>;
  hasDeckWith?: InputMaybe<Array<DeckWhereInput>>;
  /** has_farm_planner_icon field predicates */
  hasFarmPlannerIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasFarmPlannerIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** has_fell_trees_icon field predicates */
  hasFellTreesIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasFellTreesIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** has_food_provider_icon field predicates */
  hasFoodProviderIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasFoodProviderIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** has_goods_provider_icon field predicates */
  hasGoodsProviderIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasGoodsProviderIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** has_hiring_fare_icon field predicates */
  hasHiringFareIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasHiringFareIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** has_livestock_provider_icon field predicates */
  hasLivestockProviderIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasLivestockProviderIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** has_negative_bonus_point_icon field predicates */
  hasNegativeBonusPointIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasNegativeBonusPointIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** has_pan_icon field predicates */
  hasPanIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasPanIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** has_points_provider_icon field predicates */
  hasPointsProviderIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasPointsProviderIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** products edge predicates */
  hasProducts?: InputMaybe<Scalars['Boolean']['input']>;
  hasProductsWith?: InputMaybe<Array<ProductWhereInput>>;
  /** revision edge predicates */
  hasRevision?: InputMaybe<Scalars['Boolean']['input']>;
  hasRevisionWith?: InputMaybe<Array<RevisionWhereInput>>;
  /** has_slash_and_burn_icon field predicates */
  hasSlashAndBurnIcon?: InputMaybe<Scalars['Boolean']['input']>;
  hasSlashAndBurnIconNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_official_ja field predicates */
  isOfficialJa?: InputMaybe<Scalars['Boolean']['input']>;
  isOfficialJaNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** literal_id field predicates */
  literalID?: InputMaybe<Scalars['String']['input']>;
  literalIDContains?: InputMaybe<Scalars['String']['input']>;
  literalIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  literalIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  literalIDGT?: InputMaybe<Scalars['String']['input']>;
  literalIDGTE?: InputMaybe<Scalars['String']['input']>;
  literalIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  literalIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  literalIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  literalIDLT?: InputMaybe<Scalars['String']['input']>;
  literalIDLTE?: InputMaybe<Scalars['String']['input']>;
  literalIDNEQ?: InputMaybe<Scalars['String']['input']>;
  literalIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** min_players_number field predicates */
  minPlayersNumber?: InputMaybe<Scalars['Int']['input']>;
  minPlayersNumberGT?: InputMaybe<Scalars['Int']['input']>;
  minPlayersNumberGTE?: InputMaybe<Scalars['Int']['input']>;
  minPlayersNumberIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  minPlayersNumberIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  minPlayersNumberLT?: InputMaybe<Scalars['Int']['input']>;
  minPlayersNumberLTE?: InputMaybe<Scalars['Int']['input']>;
  minPlayersNumberNEQ?: InputMaybe<Scalars['Int']['input']>;
  minPlayersNumberNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  minPlayersNumberNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** name_en field predicates */
  nameEn?: InputMaybe<Scalars['String']['input']>;
  nameEnContains?: InputMaybe<Scalars['String']['input']>;
  nameEnContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEnEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameEnGT?: InputMaybe<Scalars['String']['input']>;
  nameEnGTE?: InputMaybe<Scalars['String']['input']>;
  nameEnHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameEnHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameEnIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameEnIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameEnLT?: InputMaybe<Scalars['String']['input']>;
  nameEnLTE?: InputMaybe<Scalars['String']['input']>;
  nameEnNEQ?: InputMaybe<Scalars['String']['input']>;
  nameEnNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameEnNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** name_ja field predicates */
  nameJa?: InputMaybe<Scalars['String']['input']>;
  nameJaContains?: InputMaybe<Scalars['String']['input']>;
  nameJaContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameJaEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameJaGT?: InputMaybe<Scalars['String']['input']>;
  nameJaGTE?: InputMaybe<Scalars['String']['input']>;
  nameJaHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameJaHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameJaIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameJaIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameJaLT?: InputMaybe<Scalars['String']['input']>;
  nameJaLTE?: InputMaybe<Scalars['String']['input']>;
  nameJaNEQ?: InputMaybe<Scalars['String']['input']>;
  nameJaNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameJaNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<CardWhereInput>;
  /** note field predicates */
  note?: InputMaybe<Scalars['String']['input']>;
  noteContains?: InputMaybe<Scalars['String']['input']>;
  noteContainsFold?: InputMaybe<Scalars['String']['input']>;
  noteEqualFold?: InputMaybe<Scalars['String']['input']>;
  noteGT?: InputMaybe<Scalars['String']['input']>;
  noteGTE?: InputMaybe<Scalars['String']['input']>;
  noteHasPrefix?: InputMaybe<Scalars['String']['input']>;
  noteHasSuffix?: InputMaybe<Scalars['String']['input']>;
  noteIn?: InputMaybe<Array<Scalars['String']['input']>>;
  noteIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  noteLT?: InputMaybe<Scalars['String']['input']>;
  noteLTE?: InputMaybe<Scalars['String']['input']>;
  noteNEQ?: InputMaybe<Scalars['String']['input']>;
  noteNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  noteNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  or?: InputMaybe<Array<CardWhereInput>>;
  /** play_agricola_card_id field predicates */
  playAgricolaCardID?: InputMaybe<Scalars['String']['input']>;
  playAgricolaCardIDContains?: InputMaybe<Scalars['String']['input']>;
  playAgricolaCardIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  playAgricolaCardIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  playAgricolaCardIDGT?: InputMaybe<Scalars['String']['input']>;
  playAgricolaCardIDGTE?: InputMaybe<Scalars['String']['input']>;
  playAgricolaCardIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  playAgricolaCardIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  playAgricolaCardIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  playAgricolaCardIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  playAgricolaCardIDLT?: InputMaybe<Scalars['String']['input']>;
  playAgricolaCardIDLTE?: InputMaybe<Scalars['String']['input']>;
  playAgricolaCardIDNEQ?: InputMaybe<Scalars['String']['input']>;
  playAgricolaCardIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  playAgricolaCardIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** prerequisite field predicates */
  prerequisite?: InputMaybe<Scalars['String']['input']>;
  prerequisiteContains?: InputMaybe<Scalars['String']['input']>;
  prerequisiteContainsFold?: InputMaybe<Scalars['String']['input']>;
  prerequisiteEqualFold?: InputMaybe<Scalars['String']['input']>;
  prerequisiteGT?: InputMaybe<Scalars['String']['input']>;
  prerequisiteGTE?: InputMaybe<Scalars['String']['input']>;
  prerequisiteHasPrefix?: InputMaybe<Scalars['String']['input']>;
  prerequisiteHasSuffix?: InputMaybe<Scalars['String']['input']>;
  prerequisiteIn?: InputMaybe<Array<Scalars['String']['input']>>;
  prerequisiteIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  prerequisiteLT?: InputMaybe<Scalars['String']['input']>;
  prerequisiteLTE?: InputMaybe<Scalars['String']['input']>;
  prerequisiteNEQ?: InputMaybe<Scalars['String']['input']>;
  prerequisiteNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  prerequisiteNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** printed_id field predicates */
  printedID?: InputMaybe<Scalars['String']['input']>;
  printedIDContains?: InputMaybe<Scalars['String']['input']>;
  printedIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  printedIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  printedIDGT?: InputMaybe<Scalars['String']['input']>;
  printedIDGTE?: InputMaybe<Scalars['String']['input']>;
  printedIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  printedIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  printedIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  printedIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  printedIDLT?: InputMaybe<Scalars['String']['input']>;
  printedIDLTE?: InputMaybe<Scalars['String']['input']>;
  printedIDNEQ?: InputMaybe<Scalars['String']['input']>;
  printedIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  printedIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** revision_id field predicates */
  revisionID?: InputMaybe<Scalars['ID']['input']>;
  revisionIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  revisionIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  revisionIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** special_victory_point field predicates */
  specialVictoryPoint?: InputMaybe<Scalars['String']['input']>;
  specialVictoryPointContains?: InputMaybe<Scalars['String']['input']>;
  specialVictoryPointContainsFold?: InputMaybe<Scalars['String']['input']>;
  specialVictoryPointEqualFold?: InputMaybe<Scalars['String']['input']>;
  specialVictoryPointGT?: InputMaybe<Scalars['String']['input']>;
  specialVictoryPointGTE?: InputMaybe<Scalars['String']['input']>;
  specialVictoryPointHasPrefix?: InputMaybe<Scalars['String']['input']>;
  specialVictoryPointHasSuffix?: InputMaybe<Scalars['String']['input']>;
  specialVictoryPointIn?: InputMaybe<Array<Scalars['String']['input']>>;
  specialVictoryPointIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  specialVictoryPointLT?: InputMaybe<Scalars['String']['input']>;
  specialVictoryPointLTE?: InputMaybe<Scalars['String']['input']>;
  specialVictoryPointNEQ?: InputMaybe<Scalars['String']['input']>;
  specialVictoryPointNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  specialVictoryPointNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** victory_point field predicates */
  victoryPoint?: InputMaybe<Scalars['Int']['input']>;
  victoryPointGT?: InputMaybe<Scalars['Int']['input']>;
  victoryPointGTE?: InputMaybe<Scalars['Int']['input']>;
  victoryPointIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  victoryPointIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  victoryPointLT?: InputMaybe<Scalars['Int']['input']>;
  victoryPointLTE?: InputMaybe<Scalars['Int']['input']>;
  victoryPointNEQ?: InputMaybe<Scalars['Int']['input']>;
  victoryPointNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  victoryPointNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Deck = Node & {
  __typename?: 'Deck';
  cards: CardConnection;
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  nameEn?: Maybe<Scalars['String']['output']>;
  nameJa?: Maybe<Scalars['String']['output']>;
  revision: Revision;
  revisionID: Scalars['ID']['output'];
};


export type DeckCardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CardWhereInput>;
};

/**
 * DeckWhereInput is used for filtering Deck objects.
 * Input was generated by ent.
 */
export type DeckWhereInput = {
  and?: InputMaybe<Array<DeckWhereInput>>;
  /** cards edge predicates */
  hasCards?: InputMaybe<Scalars['Boolean']['input']>;
  hasCardsWith?: InputMaybe<Array<CardWhereInput>>;
  /** revision edge predicates */
  hasRevision?: InputMaybe<Scalars['Boolean']['input']>;
  hasRevisionWith?: InputMaybe<Array<RevisionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** key field predicates */
  key?: InputMaybe<Scalars['String']['input']>;
  keyContains?: InputMaybe<Scalars['String']['input']>;
  keyContainsFold?: InputMaybe<Scalars['String']['input']>;
  keyEqualFold?: InputMaybe<Scalars['String']['input']>;
  keyGT?: InputMaybe<Scalars['String']['input']>;
  keyGTE?: InputMaybe<Scalars['String']['input']>;
  keyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  keyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  keyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  keyLT?: InputMaybe<Scalars['String']['input']>;
  keyLTE?: InputMaybe<Scalars['String']['input']>;
  keyNEQ?: InputMaybe<Scalars['String']['input']>;
  keyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name_en field predicates */
  nameEn?: InputMaybe<Scalars['String']['input']>;
  nameEnContains?: InputMaybe<Scalars['String']['input']>;
  nameEnContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEnEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameEnGT?: InputMaybe<Scalars['String']['input']>;
  nameEnGTE?: InputMaybe<Scalars['String']['input']>;
  nameEnHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameEnHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameEnIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameEnIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameEnLT?: InputMaybe<Scalars['String']['input']>;
  nameEnLTE?: InputMaybe<Scalars['String']['input']>;
  nameEnNEQ?: InputMaybe<Scalars['String']['input']>;
  nameEnNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameEnNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** name_ja field predicates */
  nameJa?: InputMaybe<Scalars['String']['input']>;
  nameJaContains?: InputMaybe<Scalars['String']['input']>;
  nameJaContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameJaEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameJaGT?: InputMaybe<Scalars['String']['input']>;
  nameJaGTE?: InputMaybe<Scalars['String']['input']>;
  nameJaHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameJaHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameJaIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameJaIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameJaLT?: InputMaybe<Scalars['String']['input']>;
  nameJaLTE?: InputMaybe<Scalars['String']['input']>;
  nameJaNEQ?: InputMaybe<Scalars['String']['input']>;
  nameJaNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameJaNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<DeckWhereInput>;
  or?: InputMaybe<Array<DeckWhereInput>>;
  /** revision_id field predicates */
  revisionID?: InputMaybe<Scalars['ID']['input']>;
  revisionIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  revisionIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  revisionIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type Product = Node & {
  __typename?: 'Product';
  cards: CardConnection;
  id: Scalars['ID']['output'];
  isOfficialJa: Scalars['Boolean']['output'];
  nameEn?: Maybe<Scalars['String']['output']>;
  nameJa?: Maybe<Scalars['String']['output']>;
  publishedYear?: Maybe<Scalars['Int']['output']>;
  revision: Revision;
  revisionID: Scalars['ID']['output'];
};


export type ProductCardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CardWhereInput>;
};

/**
 * ProductWhereInput is used for filtering Product objects.
 * Input was generated by ent.
 */
export type ProductWhereInput = {
  and?: InputMaybe<Array<ProductWhereInput>>;
  /** cards edge predicates */
  hasCards?: InputMaybe<Scalars['Boolean']['input']>;
  hasCardsWith?: InputMaybe<Array<CardWhereInput>>;
  /** revision edge predicates */
  hasRevision?: InputMaybe<Scalars['Boolean']['input']>;
  hasRevisionWith?: InputMaybe<Array<RevisionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_official_ja field predicates */
  isOfficialJa?: InputMaybe<Scalars['Boolean']['input']>;
  isOfficialJaNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** name_en field predicates */
  nameEn?: InputMaybe<Scalars['String']['input']>;
  nameEnContains?: InputMaybe<Scalars['String']['input']>;
  nameEnContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEnEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameEnGT?: InputMaybe<Scalars['String']['input']>;
  nameEnGTE?: InputMaybe<Scalars['String']['input']>;
  nameEnHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameEnHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameEnIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameEnIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameEnLT?: InputMaybe<Scalars['String']['input']>;
  nameEnLTE?: InputMaybe<Scalars['String']['input']>;
  nameEnNEQ?: InputMaybe<Scalars['String']['input']>;
  nameEnNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameEnNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** name_ja field predicates */
  nameJa?: InputMaybe<Scalars['String']['input']>;
  nameJaContains?: InputMaybe<Scalars['String']['input']>;
  nameJaContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameJaEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameJaGT?: InputMaybe<Scalars['String']['input']>;
  nameJaGTE?: InputMaybe<Scalars['String']['input']>;
  nameJaHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameJaHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameJaIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameJaIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameJaLT?: InputMaybe<Scalars['String']['input']>;
  nameJaLTE?: InputMaybe<Scalars['String']['input']>;
  nameJaNEQ?: InputMaybe<Scalars['String']['input']>;
  nameJaNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameJaNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<ProductWhereInput>;
  or?: InputMaybe<Array<ProductWhereInput>>;
  /** published_year field predicates */
  publishedYear?: InputMaybe<Scalars['Int']['input']>;
  publishedYearGT?: InputMaybe<Scalars['Int']['input']>;
  publishedYearGTE?: InputMaybe<Scalars['Int']['input']>;
  publishedYearIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  publishedYearIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  publishedYearLT?: InputMaybe<Scalars['Int']['input']>;
  publishedYearLTE?: InputMaybe<Scalars['Int']['input']>;
  publishedYearNEQ?: InputMaybe<Scalars['Int']['input']>;
  publishedYearNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  publishedYearNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** revision_id field predicates */
  revisionID?: InputMaybe<Scalars['ID']['input']>;
  revisionIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  revisionIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  revisionIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type Query = {
  __typename?: 'Query';
  cardSpecialColors: Array<CardSpecialColor>;
  cardTypes: Array<CardType>;
  cards: CardConnection;
  decks: Array<Deck>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  products: Array<Product>;
  revisions: Array<Revision>;
};


export type QueryCardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CardWhereInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};

export type Revision = Node & {
  __typename?: 'Revision';
  cards: CardConnection;
  decks?: Maybe<Array<Deck>>;
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  nameEn?: Maybe<Scalars['String']['output']>;
  nameJa?: Maybe<Scalars['String']['output']>;
  products?: Maybe<Array<Product>>;
};


export type RevisionCardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CardWhereInput>;
};

/**
 * RevisionWhereInput is used for filtering Revision objects.
 * Input was generated by ent.
 */
export type RevisionWhereInput = {
  and?: InputMaybe<Array<RevisionWhereInput>>;
  /** cards edge predicates */
  hasCards?: InputMaybe<Scalars['Boolean']['input']>;
  hasCardsWith?: InputMaybe<Array<CardWhereInput>>;
  /** decks edge predicates */
  hasDecks?: InputMaybe<Scalars['Boolean']['input']>;
  hasDecksWith?: InputMaybe<Array<DeckWhereInput>>;
  /** products edge predicates */
  hasProducts?: InputMaybe<Scalars['Boolean']['input']>;
  hasProductsWith?: InputMaybe<Array<ProductWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** key field predicates */
  key?: InputMaybe<Scalars['String']['input']>;
  keyContains?: InputMaybe<Scalars['String']['input']>;
  keyContainsFold?: InputMaybe<Scalars['String']['input']>;
  keyEqualFold?: InputMaybe<Scalars['String']['input']>;
  keyGT?: InputMaybe<Scalars['String']['input']>;
  keyGTE?: InputMaybe<Scalars['String']['input']>;
  keyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  keyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  keyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  keyLT?: InputMaybe<Scalars['String']['input']>;
  keyLTE?: InputMaybe<Scalars['String']['input']>;
  keyNEQ?: InputMaybe<Scalars['String']['input']>;
  keyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name_en field predicates */
  nameEn?: InputMaybe<Scalars['String']['input']>;
  nameEnContains?: InputMaybe<Scalars['String']['input']>;
  nameEnContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEnEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameEnGT?: InputMaybe<Scalars['String']['input']>;
  nameEnGTE?: InputMaybe<Scalars['String']['input']>;
  nameEnHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameEnHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameEnIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameEnIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameEnLT?: InputMaybe<Scalars['String']['input']>;
  nameEnLTE?: InputMaybe<Scalars['String']['input']>;
  nameEnNEQ?: InputMaybe<Scalars['String']['input']>;
  nameEnNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameEnNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** name_ja field predicates */
  nameJa?: InputMaybe<Scalars['String']['input']>;
  nameJaContains?: InputMaybe<Scalars['String']['input']>;
  nameJaContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameJaEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameJaGT?: InputMaybe<Scalars['String']['input']>;
  nameJaGTE?: InputMaybe<Scalars['String']['input']>;
  nameJaHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameJaHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameJaIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameJaIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameJaLT?: InputMaybe<Scalars['String']['input']>;
  nameJaLTE?: InputMaybe<Scalars['String']['input']>;
  nameJaNEQ?: InputMaybe<Scalars['String']['input']>;
  nameJaNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameJaNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<RevisionWhereInput>;
  or?: InputMaybe<Array<RevisionWhereInput>>;
};

export type GetCardsDetailByRevisionQueryVariables = Exact<{
  revisionKey: Scalars['String']['input'];
}>;


export type GetCardsDetailByRevisionQuery = { __typename?: 'Query', cards: { __typename?: 'CardConnection', totalCount: number, edges?: Array<{ __typename?: 'CardEdge', node?: { __typename?: 'Card', literalID: string, printedID?: string | null, playAgricolaCardID?: string | null, nameJa?: string | null, nameEn?: string | null, minPlayersNumber?: number | null, prerequisite?: string | null, cost?: string | null, description?: string | null, note?: string | null, isOfficialJa: boolean, victoryPoint?: number | null, specialVictoryPoint?: string | null, hasArrow: boolean, hasBonusPointIcon: boolean, hasNegativeBonusPointIcon: boolean, hasPanIcon: boolean, hasBreadIcon: boolean, hasFarmPlannerIcon: boolean, hasActionsBoosterIcon: boolean, hasPointsProviderIcon: boolean, hasGoodsProviderIcon: boolean, hasFoodProviderIcon: boolean, hasCropProviderIcon: boolean, hasBuildingResourceProviderIcon: boolean, hasLivestockProviderIcon: boolean, hasCutPeatIcon: boolean, hasFellTreesIcon: boolean, hasSlashAndBurnIcon: boolean, hasHiringFareIcon: boolean, deck?: { __typename?: 'Deck', id: string, nameJa?: string | null } | null, products?: Array<{ __typename?: 'Product', id: string, nameJa?: string | null }> | null, cardType: { __typename?: 'CardType', key: string, nameJa?: string | null }, cardSpecialColor?: { __typename?: 'CardSpecialColor', key: string } | null, children?: Array<{ __typename?: 'Card', literalID: string, printedID?: string | null, nameJa?: string | null, revision: { __typename?: 'Revision', id: string, key: string } }> | null, ancestors?: Array<{ __typename?: 'Card', literalID: string, printedID?: string | null, nameJa?: string | null, revision: { __typename?: 'Revision', id: string, key: string } }> | null } | null } | null> | null } };

export type GetCardsListQueryVariables = Exact<{
  where: CardWhereInput;
  after?: InputMaybe<Scalars['Cursor']['input']>;
}>;


export type GetCardsListQuery = { __typename?: 'Query', cards: { __typename?: 'CardConnection', totalCount: number, edges?: Array<{ __typename?: 'CardEdge', node?: { __typename?: 'Card', literalID: string, printedID?: string | null, nameJa?: string | null, nameEn?: string | null, cardType: { __typename?: 'CardType', key: string }, cardSpecialColor?: { __typename?: 'CardSpecialColor', key: string } | null, revision: { __typename?: 'Revision', id: string, key: string } } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, endCursor?: any | null } } };

export type GetDecksAndProductsListQueryVariables = Exact<{ [key: string]: never; }>;


export type GetDecksAndProductsListQuery = { __typename?: 'Query', decks: Array<{ __typename?: 'Deck', id: string, nameJa?: string | null, revision: { __typename?: 'Revision', key: string } }>, products: Array<{ __typename?: 'Product', id: string, nameJa?: string | null, revision: { __typename?: 'Revision', key: string } }> };


export const GetCardsDetailByRevisionDocument = gql`
    query GetCardsDetailByRevision($revisionKey: String!) {
  cards(where: {hasRevisionWith: {key: $revisionKey}}) {
    edges {
      node {
        literalID
        printedID
        playAgricolaCardID
        deck {
          id
          nameJa
        }
        products {
          id
          nameJa
        }
        cardType {
          key
          nameJa
        }
        cardSpecialColor {
          key
        }
        nameJa
        nameEn
        minPlayersNumber
        prerequisite
        cost
        description
        note
        isOfficialJa
        victoryPoint
        specialVictoryPoint
        hasArrow
        hasBonusPointIcon
        hasNegativeBonusPointIcon
        hasPanIcon
        hasBreadIcon
        hasFarmPlannerIcon
        hasActionsBoosterIcon
        hasPointsProviderIcon
        hasGoodsProviderIcon
        hasFoodProviderIcon
        hasCropProviderIcon
        hasBuildingResourceProviderIcon
        hasLivestockProviderIcon
        hasCutPeatIcon
        hasFellTreesIcon
        hasSlashAndBurnIcon
        hasHiringFareIcon
        children {
          revision {
            id
            key
          }
          literalID
          printedID
          nameJa
        }
        ancestors {
          revision {
            id
            key
          }
          literalID
          printedID
          nameJa
        }
      }
    }
    totalCount
  }
}
    `;
export const GetCardsListDocument = gql`
    query GetCardsList($where: CardWhereInput!, $after: Cursor) {
  cards(where: $where, first: 50, after: $after) {
    edges {
      node {
        literalID
        printedID
        cardType {
          key
        }
        cardSpecialColor {
          key
        }
        revision {
          id
          key
        }
        nameJa
        nameEn
      }
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      endCursor
    }
    totalCount
  }
}
    `;
export const GetDecksAndProductsListDocument = gql`
    query GetDecksAndProductsList {
  decks {
    id
    nameJa
    revision {
      key
    }
  }
  products {
    id
    nameJa
    revision {
      key
    }
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string, variables?: any) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType, variables) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    GetCardsDetailByRevision(variables: GetCardsDetailByRevisionQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCardsDetailByRevisionQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCardsDetailByRevisionQuery>(GetCardsDetailByRevisionDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetCardsDetailByRevision', 'query', variables);
    },
    GetCardsList(variables: GetCardsListQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCardsListQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCardsListQuery>(GetCardsListDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetCardsList', 'query', variables);
    },
    GetDecksAndProductsList(variables?: GetDecksAndProductsListQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetDecksAndProductsListQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetDecksAndProductsListQuery>(GetDecksAndProductsListDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetDecksAndProductsList', 'query', variables);
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;